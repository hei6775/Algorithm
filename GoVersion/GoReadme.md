## `go build`命令

| 参数 | 描述 |
| :------:| ----------- |
| -a | 强制重建已经是最新的软件包 |
| -n | 打印编译时会用到的所有命令，但不真正执行 |
| -p n | 开启并发编译，默认情况下该值为 CPU 逻辑核数 |
| -race | 启用数据竞争检测。<br />仅支持linux / amd64，freebsd / amd64，darwin / amd64和windows / amd64。 |
| -msan | 启用与内存清理程序的互操作。<br />仅在linux / amd64上支持，并且仅作为主机C编译器使用Clang / LLVM。 |
| -v | 在编译包时打印包的名称 |
| -work | 打印临时工作目录的名称，退出时不删除它 |
| -x | 打印编译时会用到的所有命令 |
| -asmflags | 此标记可以后跟另外一些标记，如-D、-I、-S等。这些后跟的标记用于控制Go语言编译器编译汇编语言文件时的行为 |
| -buildmode | 此标记用于指定编译模式，使用方式如-buildmode=default（这等同于默认情况下的设置）。此标记支持的编译模式目前有6种。借此，我们可以控制编译器在编译完成后生成静态链接库（即.a文件，也就是我们之前说的归档文件）、动态链接库（即.so文件）或/和可执行文件（在Windows下是.exe文件）。 |
| -compiler | 此标记用于指定当前使用的编译器的名称。其值可以为gc或gccgo。其中，gc编译器即为Go语言自带的编辑器，而gccgo编译器则为GCC提供的Go语言编译器。而GCC则是GNU项目出品的编译器套件。GNU是一个众所周知的自由软件项目。在开源软件界不应该有人不知道它。好吧，如果你确实不知道它，赶紧去google吧。 |
| -gccgoflags | 此标记用于指定需要传递给gccgo编译器或链接器的标记的列表。 |
| -gcflags | 此标记用于指定需要传递给go tool compile命令的标记的列表。 |
| -installsuffix | 为了使当前的输出目录与默认的编译输出目录分离，可以使用这个标记。此标记的值会作为结果文件的父目录名称的后缀。其实，如果使用了-race标记，这个标记会被自动追加且其值会为race。如果我们同时使用了-race标记和-installsuffix，那么在-installsuffix标记的值的后面会再被追加_race，并以此来作为实际使用的后缀。 |
| -ldflags | 此标记用于指定需要传递给go tool link命令的标记的列表。 |
| -linkshared | 此标记用于与-buildmode=shared一同使用。后者会使作为编译目标的非main代码包都被合并到一个动态链接库文件中，而前者则会在此之上进行链接操作。 |
| -pkgdir | 使用此标记可以指定一个目录。编译器会只从该目录中加载代码包的归档文件，并会把编译可能会生成的代码包归档文件放置在该目录下 |
| -tags | 此标记用于指定在实际编译期间需要受理的编译标签（也可被称为编译约束）的列表。这些编译标签一般会作为源码文件开始处的注释的一部分 |
| -toolexec | 此标记可以让我们去自定义在编译期间使用一些Go语言自带工具（如vet、asm等）的方式。 |


打印优化决策

`go build --gcflags=-m main.go`

有时候分析会需要研究生成的汇编代码，这里介绍生成汇编代码的方法。

`go tool 6g -S hello.go`

-S参数表示打印出汇编代码，更多参数可以通过-h参数查看

`go tool 6g -h`

或者可以反汇编生成的可执行文件：
```PowerShell
go build test.go
go tool 6l -a test | less
```
本机是amd64的机器，如果是i386的机器，则命令是8g

