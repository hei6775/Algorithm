- 乐观锁和悲观锁

悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。

- 什么是意向锁

MMAPV1 存储引擎锁的最小粒度为 Collection 级别，包括读锁（S）、写锁（X），并且还提供了意向读锁（IS）、意向写锁（IX），意向锁会加在比读写锁更高的粒度上，比如在 Collection 上加了读锁，相应的会在 db、Global 加意向读锁。

意向锁并不是真正的锁，只是表达了加锁的意向，所以意向锁之间是互相兼容的。X 锁和任何锁都是互斥的，包括 IX 锁，比如当前要更新 Collection 中的一个 document，使得该 Collection 被加了 X 锁，IX 锁会自动加载 Collection 所在 db、global 上，此时如果要在 db 级别做更新操作就需要在 db 上加 X 锁，由于 db 上已经有了 IX 锁，所以 db 级别的更新操作被阻塞。

意向锁的意义在于让更大级别的更新操作可以立即看到是否有小级别的更新操作在进行（如果没有意向锁，大更新操作要判断是否有小更新操作在进行，就需要遍历整个表），如果有，则大操作需要等待小操作释放锁（从而释放意向锁），如果没有，则可以放心的进行大操作。

- MongoDB 的事务功能

  4.0 版之前只支持单行或者单文档事务，4.0 版推出多文档事务，所以说它和 MYSQL 的数据库是不一样的。未来 4.2 版有可能推出 sharing 的多文档事务。

- MongoDB 的预分配模型

Power of 2 Sized Allocations：默认情况下，MMAPv1 中空间分配使用此策略，每个 document 的 size 是 2 的次幂，比如 32、64、128、256...2MB，如果文档尺寸大于 2MB，则空间为 2MB 的倍数（2M,4M,6M 等）。这种策略有 2 种优势，首先那些删除或者 update 变大而产生的磁盘碎片空间（尺寸变大，意味着开辟新空间存储此 document，旧的空间被 mark 为 deleted）可以被其他 insert 重用，再者 padding 可以允许文档尺寸有限度的增长，而无需每次 update 变大都重新分配空间。此外，mongodb 还提供了一个可选的“No padding Allocation”策略（即按照实际数据尺寸分配空间），如果你确信数据绝大多数情况下都是 insert、in-place update，极少的 delete，此策略将可以有效的节约磁盘空间，看起来数据更加紧凑，磁盘利用率也更高。

- MongoDB 提供了什么样的隔离保证？

MongoDB 在并行读写的时候提供了如下的保证，MMAPv1 或 WiredTiger 都会提供这些保证：
　 1. 在单一的文档中读写操作都是原子的，永远不会把一个文档置于不一致状态。这个意味着一个读者永远不会看到一个部分内容更新的文档，索引也会和集合内容一直保持一致。此外，在一个文档中的一系列读、写操作都是串行的。
　 2. 像 db.collection.find()这种查询谓词只会返回匹配的文档，db.collection.update()也只会更新匹配的文档。（废话）
　 3. 对于一个排序的读操作（例如，db.collection.find()、db.collection.aggregate()），排序的顺序并不会因为并发的写入而会被打乱。（不太理解）
　尽管在单个文档操作中 MongoDB 提供了这些隔离保证，但是在程序执行期间可能会读写任意数量的文档，对于这种多个文档的读写 MongoDB 是没有提供事务所以在并发写的时候是不保证隔离的。这个意味着如下的一些情况可能会出现，无论是在 MMAPv1 或 WiredTiger 引擎中。
　 1. Non-point-in-time read operations。这里直接把原文给贴出来了，因为我实在不知道该怎么翻译这个，我理解就是数据库事务隔离中的"不可重复读"。例如，在时间点 t1 开始读取文档（db.collection.find({"status_id":{\$lt:20}})），一个更新文档的操作在稍后的 t2 时刻发生（db.collection.update({"status_id":10},{"name":"andy"})），status_id = 10 的文档最后查找出来的结果可能会是更新后的文档，也就是说 MongoDB 不能看到查找时刻的快照数据。这种情况在 PG 的"Repeatable reads （可重复读）"事务隔离级别中就不会出现，PG 最后的结果会是事务（也就是查询开始之前）之前的快照数据，更新的内容不会出现在结果中。
　 2. 非串行操作。假设我们在 t1 时刻读取文档 d1，在稍后的 t3 时刻更新文档 d1，这种称为读-写依赖，如果我们的操作是串行，那么读操作就必须在写操作之前被处理。再假设如果在 t2 时刻更新文档 t2，在稍后的 t4 时刻我们有一个对文档 t2 的读操作，这种称为写-读依赖，在串行调度中这就需要读操作在写操作之后。上面这两种情况组合在一起就会导致循环依赖，这样也就是导致了串行调度不可行。
　 3. Dropped results。MongoDB 在读取文档的时候可能会存在有部分匹配的文档读取失败情况，因为在这个过程中可能会有文档被更新、删除。但是只要在查找过程中没有被修改那么肯定能读取到匹配的文档。说到底还是因为没有事务导致的。
